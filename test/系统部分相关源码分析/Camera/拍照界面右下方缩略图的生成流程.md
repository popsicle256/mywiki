date：2024-02-06  
缩略图的生成主要有两种方式：  
1、点击拍照，拍照完成后缩略图更新为刚拍的图片  
2、进入相机界面时，缩略图加载为相机拍的最后一张图片  

这两种方式的流程有较大不同，其中第一种为实时生成，第二种为从数据库中加载。  
# 1 点击拍照完成后更新缩略图
点击拍照，拍照完成后，会直接实时生成图片和对应的缩略图并将缩略图更新到拍照界面的右下角，该缩略图是由**图片byte数据**转换成bitmap形式而来。

大致过程描述：  
	PhotoMode.doShutterButtonClick() 点击拍照按钮，设备更新状态，触发相机设备进行拍照 -> takePicture()  
	PhotoDevice2Controller.takePicture() 首先构建builder：配置拍照信息、注册图像可用监听器等（doCreateAndConfigRequest()），然后触发相机进行捕获操作session：发送拍照信息和监听器（capture()）  
	当相机捕获完成后，会回调ImageReader.postEventFromNative()，该方法在当图像可用时会触发之前在takePicture中注册的**图像可用监听器**  
	CaptureSurface收到图像可用消息，进入onImageAvailable()：从**ImageReader中读取最新图片，并将其转换成byte数据形式**，通过回调传送到PhotoDevice2Controller中  
	PhotoDevice2Controller.onPictureCallback()接到回调，传递**byte数据**回调到PhotoMode中  
	PhotoMode.onPostViewCallback()接到回调，开始处理生成缩略图，需要将传入的byte数据转换成bitmap形式的缩略图，这个转换过程中涉及到图像的尺寸和质量，生成完成后，就调用UI的更新缩略图方法  
	CameraAppUI中调用ThumbnailViewManager，将传入的bitmap缩略图更新到相机界面视图中（拍照界面右下角）  
## 1.1 ThumbnailViewManager.updateThumbnail()
**ThumbnailViewManager.updateThumbnail(Bitmap bitmap)**  
`vendor/mediatek/proprietary/packages/apps/Camera2/host/src/com/mediatek/camera/ui/ThumbnailViewManager.java`  

```java
    // 传入缩略图更新（只有拍照完成后的更新才走此处）
    public void updateThumbnail(Bitmap bitmap) {
        updateThumbnailView(bitmap);  // 更新缩略图
        if (bitmap != null) {
            doAnimation(mAnimationView);
        } else {
            // for security camera not query db.
            mThumbnailView.setImageDrawable(mRoundDrawable);
            mIsNeedQueryDB = false;
        }
    }
    // 更新相机界面的缩略图
    private void updateThumbnailView(Bitmap bitmap) {
        LogHelper.d(TAG, "[updateThumbnailView]...");
        if (mThumbnailView != null) {
            if (bitmap != null) {
                LogHelper.d(TAG, "[updateThumbnailView] set created thumbnail");
                mRoundDrawable = createRoundDrawable(bitmap, THUMB_COLOR);
            } else {
                LogHelper.d(TAG, "[updateThumbnailView] set default thumbnail");
                mRoundDrawable = createRoundDrawable(null, THUMB_COLOR);
            }
        }
    }
```
## 1.2 CameraAppUI.updateThumbnail()
**CameraAppUI.updateThumbnail(final Bitmap bitmap)**  

ThumbnailViewManager.updateThumbnail()中bitmap的来源    

`vendor/mediatek/proprietary/packages/apps/Camera2/host/src/com/mediatek/camera/ui/CameraAppUI.java`  
```java
    /**
     * Update thumbnailView, when the bitmap finished update, is will be recycled
     * immediately, do not use the bitmap again!
     * @param bitmap
     *            the bitmap matched with the picture or video, such as
     *            orientation, content. suggest thumbnail view size.
     */
    public void updateThumbnail(final Bitmap bitmap) {
        if (mThumbnailViewManager != null) {
            mApp.getActivity().runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    mThumbnailViewManager.updateThumbnail(bitmap);  // width = 36  height = 48  更新缩略图 libin
                    if (bitmap != null && !bitmap.isRecycled()) {
                        bitmap.recycle();
                    }
                }
            });
        }
    }
```
其中`mThumbnailViewManager = new ThumbnailViewManager(mApp, parentView);`  
此处的bitmap依旧是从其他方法中传过来的。  

## 1.3 PhotoMode.onPostViewCallback()
**PhotoMode.onPostViewCallback(byte[] data)**  

CameraAppUI.updateThumbnail()中bitmap的来源：`mIApp.getAppUi().updateThumbnail(bitmap);`  
`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/mode/photo/PhotoMode.java`  
```java
    @Override
    public void onPostViewCallback(byte[] data) {
        LogHelper.d(TAG, "[onPostViewCallback] data = " + data + ",mIsResumed = " + mIsResumed);
        CameraSysTrace.onEventSystrace(POST_VIEW_CALLBACK, true, true);
        if (data != null && mIsResumed) {
            //will update the thumbnail
            int rotation = CameraUtil.getJpegRotationFromDeviceSpec(Integer.parseInt(mCameraId),
                    mIApp.getGSensorOrientation(), mIApp.getActivity());
            Bitmap bitmap = BitmapCreator.createBitmapFromYuv(data,
                    ThumbnailHelper.POST_VIEW_FORMAT,
                    ThumbnailHelper.getThumbnailWidth(),
                    ThumbnailHelper.getThumbnailHeight(),
                    mIApp.getAppUi().getThumbnailViewWidth(),
                    rotation);  // bitmap width = 48  height = 36
                    //此处ThumbnailHelper.getThumbnailWidth()=192，是正常的，但经过createBitmapFromYuv后生成的bitmap为48*36）
                    // 因为mIApp.getAppUi().getThumbnailViewWidth()的值为40，该值会影响createBitmapFromYuv中缩略图的尺寸 libin
            mIApp.getAppUi().updateThumbnail(bitmap);  // 更新缩略图
        }
        CameraSysTrace.onEventSystrace(POST_VIEW_CALLBACK, false, true);
    }
```
从此处可得，前面的bitmap是在此处通过传入的**byte数组**生成的，调用`BitmapCreator.createBitmapFromYuv()`生成bitmap。  
此处值得注意的是，`ThumbnailHelper.getThumbnailWidth()`得到的值为192，而生成的bimap的width值为48，这表明在其中进行了某种计算转换，将结果bitmap的尺寸更改了。  
`mIApp.getAppUi().getThumbnailViewWidth()`：获取的是相机界面UI视图中缩略图窗口的宽度。  

### 1.3.1 BitmapCreator.createBitmapFromYuv()
**BitmapCreator.createBitmapFromYuv(byte[] yuvData, int imageFormat, int yuvWidth, int yuvHeight, int targetWidth, int orientation);**  

该方法逻辑为将输入的byte图片数据转换成一个缩略图bitmap，该bitmap是由yuvData转换而来，**为1.1中的bitmap**，也即为缩略图。  
`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/utils/BitmapCreator.java`  
```java
    /**
     * create bitmap from the YUV data.
     * @param yuvData
     *            the YUV data.
     * @param targetWidth
     *            the view width where the bitmap shows.
     * @param yuvWidth
     *            the width of YUV image.
     * @param yuvHeight
     *            the height of YUV image.
     * @param orientation
     *            the orientation of YUV image.
     * @param imageFormat
     *            the image format of YUV image, must be NV21 OR YUY2.
     * @return the bitmap decode from YUV data.
     */
    public static Bitmap createBitmapFromYuv(byte[] yuvData, int imageFormat, int yuvWidth, int yuvHeight, int targetWidth, int orientation) {
        LogHelper.d(TAG, "[createBitmapFromYuv] yuvData = " + yuvData
                + ", yuvWidth = " + yuvWidth + ", yuvHeight = " + yuvHeight
                + ", orientation = " + orientation + ", imageFormat = "
                + imageFormat);  // yuvWidth = 192, yuvHeight = 144 （在PhotoMode.onPostViewCallback()中直接设定的固定值） libin
        if (isNeedDumpYuv()) {
            dumpYuv("/sdcard/postView.yuv", yuvData);
        }
        if (yuvData != null) {
            byte[] jpeg = covertYuvDataToJpeg(yuvData, imageFormat, yuvWidth,
                    yuvHeight);
            int ratio = (int) Math.ceil((double) Math.min(yuvWidth, yuvHeight)
                    / targetWidth);  // 144/40=3.6 向上取整后的值为4 libin
            int inSampleSize = Integer.highestOneBit(ratio);  // 4 libin
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inSampleSize = inSampleSize;
            try {
                Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, 0,
                        jpeg.length, options);  // 得到的bitmap为width = 48  height = 36   options.inSampleSize=4情况下 libin
                LogHelper.d(TAG, "[createBitmapFromYuv] end");
                return rotateBitmap(bitmap, orientation);
            } catch (OutOfMemoryError e) {
                LogHelper.e(TAG, "createBitmapFromYuv fail", e);
                return null;
            }
        }
        return null;
    }
```
createBitmapFromYuv()的传入参数中，值得注意的是**targetWidth**，该值会直接影响输出bitmap的尺寸。
	可看出，该值的作用为参与`options.inSampleSize`值的计算，该值通过`BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options)`参与了bitmap的生成。
	
### 1.3.2 BitmapFactory.decodeByteArray(jpeg, 0, jpeg.length, options);
**BitmapFactory.decodeByteArray(byte[] data, int offset, int length, Options opts);**  

`frameworks/base/graphics/java/android/graphics/BitmapFactory.java`  
```java
    /**
     * Decode an immutable bitmap from the specified byte array.
     *
     * @param data byte array of compressed image data
     * @param offset offset into imageData for where the decoder should begin
     *               parsing.
     * @param length the number of bytes, beginning at offset, to parse
     * @param opts null-ok; Options that control downsampling and whether the
     *             image should be completely decoded, or just is size returned.
     * @return The decoded bitmap, or null if the image data could not be
     *         decoded, or, if opts is non-null, if opts requested only the
     *         size be returned (in opts.outWidth and opts.outHeight)
     * @throws IllegalArgumentException if {@link BitmapFactory.Options#inPreferredConfig}
     *         is {@link android.graphics.Bitmap.Config#HARDWARE}
     *         and {@link BitmapFactory.Options#inMutable} is set, if the specified color space
     *         is not {@link ColorSpace.Model#RGB RGB}, or if the specified color space's transfer
     *         function is not an {@link ColorSpace.Rgb.TransferParameters ICC parametric curve}
     */
    public static Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts) {
        if ((offset | length) < 0 || data.length < offset + length) {
            throw new ArrayIndexOutOfBoundsException();
        }
        validate(opts);
        Bitmap bm;
        Trace.traceBegin(Trace.TRACE_TAG_GRAPHICS, "decodeBitmap");
        try {
            bm = nativeDecodeByteArray(data, offset, length, opts,
                    Options.nativeInBitmap(opts),
                    Options.nativeColorSpace(opts));  // opts用于控制缩放和解码行为 libin
            if (bm == null && opts != null && opts.inBitmap != null) {
                throw new IllegalArgumentException("Problem decoding into existing bitmap");
            }
            setDensityFromOptions(bm, opts);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_GRAPHICS);
        }
        return bm;
    }
```
经验证，`options.inSampleSize`的值会直接影响生成bitmap的尺寸，但对缩略图的质量并没有明显影响（马赛克依旧存在）。  
	故该值只会影响bitmap的尺寸，而不会影响其质量，所以图片质量应该由其他因素影响。  
	而由于此处是bitmap的生成处，故合理怀疑**jpeg**参数影响了bitmap的质量。jpeg是通过`covertYuvDataToJpeg(yuvData, imageFormat, yuvWidth, yuvHeight);`得到。

### 1.3.3 BitmapCreator.covertYuvDataToJpeg();
**BitmapCreator.covertYuvDataToJpeg(byte[] data, int imageFormat, int yuvWidth, int yuvHeight);**  

生成bitmap的重要参数之一：`jpeg`
`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/utils/BitmapCreator.java`
```java
    /**
     * Encode YUV to jpeg, and crop it.
     * @param data the yuv data.
     * @param imageFormat the yuv format.
     * @param yuvWidth the yuv width.
     * @param yuvHeight the yuv height.
     * @return the jpeg data.
     */
    public static byte[] covertYuvDataToJpeg(byte[] data, int imageFormat, int yuvWidth, int yuvHeight) {
        byte[] jpeg;
        Rect rect = new Rect(0, 0, yuvWidth, yuvHeight);
        YuvImage yuvImg = new YuvImage(data, imageFormat, yuvWidth, yuvHeight, null);
        ByteArrayOutputStream outputstream = new ByteArrayOutputStream();
        int jpegQuality = CameraProfile .getJpegEncodingQualityParameter(CameraProfile.QUALITY_HIGH);  // jpegQuality=0
        // 手动改变jpegQuality值，缩略图质量情况（2无变化，10有变化，40与正常无异） libin
        yuvImg.compressToJpeg(rect, jpegQuality, outputstream);
        jpeg = outputstream.toByteArray();
        return jpeg;
    }
```
从`jpegQuality`的变量名可知为图片质量，而该值的计算过程是通过`CameraProfile .getJpegEncodingQualityParameter()`得到，从传入参数看是传入了高质量的。  
但通过打印发现，该值为0，尝试改变其值，发现缩略图质量有变化，当为40时，已经和正常缩略图无异。  

**CameraProfile .getJpegEncodingQualityParameter(CameraProfile.QUALITY_HIGH);**  
压缩byte数据得到jpeg过程中的重要参数`jpegQuality`的计算方法：  
`frameworks/base/media/java/android/media/CameraProfile.java`  
```java
    /**
     * Returns a pre-defined still image capture (jpeg) quality level
     * used for the given quality level in the Camera application for
     * the first back-facing camera on the device. If the device has no
     * back-facing camera, this returns 0.
     *
     * @param quality The target quality level
     */
    /**
     * 该方法是用于返回第一颗后摄的成像图片质量等级
     * 该方法的逻辑为：如果没有后摄，会返回0
     * 而T8340D刚好就没有后摄，所以生成的缩略图质量最低。
     * libin
     */
    public static int getJpegEncodingQualityParameter(int quality) {
        int numberOfCameras = Camera.getNumberOfCameras();
        CameraInfo cameraInfo = new CameraInfo();
        for (int i = 0; i < numberOfCameras; i++) {
            Camera.getCameraInfo(i, cameraInfo);
            if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) {  // 要求必须是后摄
                return getJpegEncodingQualityParameter(i, quality);
            }
        }
        return 0;
    }
```
从jpegQuality的计算方法可知，其是**通过获取第一个后摄的质量系数来得到**的，**如果设备没有后摄，则会直接返回0**，代表最差质量。
而T8340D新屏机器恰好无后摄，只有前摄，故会生成的缩略图质量很差，会显示为马赛克式。  

---
经上述分析，可得当前情况下的缩略图生成过程为：
	PhotoMode.onPostViewCallback()回调，通过byte数据生成bitmap缩略图，再通过CameraAppUI来更新缩略图。  
	问题就出在经由byte数据生成bitmap的过程中，生成过程中**压缩质量的计算错误**导致质量过低（源码逻辑导致）影响了bitmap的图片质量。

其中PhotoMode.onPostViewCallback()回调是什么时候产生的？
	在**1.4**中产生的，该回调即为将捕获图片的byte数据转换成缩略图并更新。  

## 1.4 PhotoDevice2Controller.onPictureCallback()
**PhotoDevice2Controller.onPictureCallback(byte[] data, int format, String captureType, int width, int height)**  
`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/mode/photo/device/PhotoDevice2Controller.java`  
```java
@Override
    public void onPictureCallback(byte[] data, int format, String captureType, int width, int height) {
        LogHelper.d(TAG, "<onPictureCallback> data = " + data + ", format = " + format
                + ", captureType = " + captureType + ", width = " + width + ", height = " + height + ", mCaptureDataCallback = " + mCaptureDataCallback);
        if (mCaptureDataCallback != null) {
            DataCallbackInfo info = new DataCallbackInfo();
            info.data = data;
            info.needUpdateThumbnail = true;
            info.needRestartPreview = false;
            info.mBufferFormat = format;
            info.imageHeight = height;
            info.imageWidth = width;
            if (ThumbnailHelper.isPostViewSupported()) {
                info.needUpdateThumbnail = false;
            }
            if (ThumbnailHelper.CAPTURE_TYPE_THUMBNAIL.equalsIgnoreCase(captureType)) {
                CameraSysTrace.onEventSystrace("photoDevice.onPostViewCallback", true, true);
                mCaptureDataCallback.onPostViewCallback(data);  // 更新缩略图 libin
                CameraSysTrace.onEventSystrace("photoDevice.onPostViewCallback", false, true);
            } else {
                CameraSysTrace.onEventSystrace("photoDevice.onJpegCallback", true, true);
                mCaptureDataCallback.onDataReceived(info);
                CameraSysTrace.onEventSystrace("photoDevice.onJpegCallback", false, true);
                boolean supportByBGService = BGServiceKeeper.supportByBGService(captureType);
                if (mIsBGServiceEnabled && mCaptureSurface != null && supportByBGService) {
                    mCaptureSurface.decreasePictureNum();
                    if (mCaptureSurface.shouldReleaseCaptureSurface()
                            && mCaptureSurface.getPictureNumLeft() == 0) {
                        mCaptureSurface.releaseCaptureSurface();
                        mCaptureSurface.releaseCaptureSurfaceLater(false);
                    }
                }
            }
        }
    }
```
此处调用callback的是`mCaptureDataCallback`，其类型为`CaptureDataCallback`，为何会走到`PhotoMode`的callback中？  
>因为`PhotoMode`实现了`CaptureDataCallback`.
  
`mCaptureDataCallback`的生成是在`PhotoDevice2Controller.takePicture()`中（**1.7**），
>而此处的`takePicture()`又是由`PhotoMode`所调用的（**1.8**），所以这里`mCaptureDataCallback.onPostViewCallback()`即为`PhotoMode.onPostViewCallback()`.
## 1.5 CaptureSurface.onImageAvailable()
通过**ImageReader**中的回调，会触发此处的`onImageAvailable()`。  

⬜此处的监听器`mCaptureImageListener`实现了`OnImageAvailableListener` 接口，它被注册到了 `ImageReader` 中。当 `ImageReader` 接收到新的图像时（**1.6**），就会触发 `onImageAvailable` 方法，从而执行 `mCaptureImageListener` 中的逻辑。（这个注册是如何实现的？）
	注册的实现在`CaptureSurface.getSurface()`中`captureImageReader.setOnImageAvailableListener(mCaptureImageListener, mCaptureHandler);`
	此处的getSurface方法，有两个调用（**1.7.1**）：1是原图生成时，2是缩略图生成时
	所以相当于在构建捕获builder时，就已经通过getSurface()注册了两个onImageAvailable的监听器，然后当底层本地方法捕获完成后，回调ImageReader时，就会回调这两个监听器，也就执行到了此处。
`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/bgservice/CaptureSurface.java`  
```java
    public final OnImageAvailableListener mCaptureImageListener = new OnImageAvailableListener() {
        @Override
        public void onImageAvailable(ImageReader imageReader) {
            String captureFormat = mImageReaderManager.getCaptureType(imageReader);
            LogHelper.d(TAG, "[onImageAvailable] mIsCreatedByBG = " + mIsCreatedByBG
                    + ", mBGEventCallbackQueue.size = " + mBGEventCallbackQueue.size()
                    + ", imageReader = " + imageReader +" captureFormat = " + captureFormat);
            if (mIsCreatedByBG && BGServiceKeeper.supportByBGService(captureFormat)) {  // 判断是否由后台服务创建&捕获格式是否支持后台服务
                if (mBGEventCallbackQueue.isEmpty()) {
                    synchronized (mImageReaderSync) {
                        mImageReaderQueue.add(imageReader);
                    }
                } else {
                    synchronized (mImageReaderSync) {
                        if (mImageCallback != null) {
                            Image image = imageReader.acquireNextImage();
                            synchronized (mBGEventCallbackQueue) {
                                if (!mBGEventCallbackQueue.isEmpty()) {
                                    LogHelper.d(TAG, "[onImageAvailable], remove CallbackQueue");
                                    mBGEventCallbackQueue.remove(0);
                                }
                            }
                            if (image == null) {
                                LogHelper.w(TAG, "[onImageAvailable] image buffer is null");
                                return;
                            }
                            int format = image.getFormat();
                            int width = image.getWidth();
                            int height = image.getHeight();
                            mImageCallback.onPictureCallback(getBuffer(image, captureFormat),
                                    format, captureFormat, width, height);
                        }
                    }
                }
            } else {  // 拍照完成后的缩略图走这里生成
                synchronized (mImageReaderSync) {
                    if (mImageCallback != null) {
                        Image image = imageReader.acquireNextImage();  // 获取最新图片
                        if (image == null) {
                            LogHelper.w(TAG, "[onImageAvailable] image buffer is null");
                            return;
                        }
                        int format = image.getFormat();
                        int width = image.getWidth();
                        int height = image.getHeight();  // width = 192  height = 144 libin
                        // 更新缩略图的callback  ？todo：此处的callback是从哪里来的
                        mImageCallback.onPictureCallback(getBuffer(image,                                           captureFormat), ormat, captureFormat, width, height);
                    }
                }
            }
        }
    };
```
这个监听器中，首先从**ImageReader**中获取到最新图片，然后通过`getBuffer()`**将图片转换成byte数组**，再调用更新缩略图。
`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/bgservice/CaptureSurface.java`
```java
    private byte[] getBuffer(Image image, String captureType) {
        synchronized (mImageReaderSync) {
            byte[] imageBuffer = null;
            LogHelper.i(TAG, "[getBuffer] image.getFormat = " + image.getFormat()
                    + " image.getWidth = " + image.getWidth() + " image.getHeight = "
                    + image.getHeight() + " format = " + image.getFormat()
                    + " captureType = " + captureType);
            if (HeifHelper.CAPTURE_TYPE_HEIF.equalsIgnoreCase(captureType)) {
                if (FormatEntry.HEIF_FLOW == FormatEntry.HEIF_AOSP_FLOW){
                    imageBuffer = HeifHelper.getHeicBuffer(image);
                }else{
                    imageBuffer = ThumbnailHelper.getDataFromImage(image);
                }
            } else if (HeifHelper.CAPTURE_TYPE_JPEG.equalsIgnoreCase(captureType)) {
                Image.Plane plane = image.getPlanes()[0];
                ByteBuffer buffer = plane.getBuffer();
                LogHelper.d(TAG, "<getBuffer> image = " + image
                        + ", buffer.remaining() = " + buffer.remaining()
                        + ", plane.getPixelStride()" + plane.getPixelStride());
                imageBuffer = new byte[buffer.remaining()];
                buffer.get(imageBuffer);
                buffer.rewind();
            } else if (ThumbnailHelper.CAPTURE_TYPE_THUMBNAIL.equalsIgnoreCase(captureType)) {
                imageBuffer = ThumbnailHelper.getYUVBuffer(image);  // 获取缩略图数据 libin
            } else {
                throw new RuntimeException("Unsupported image format.");
            }
            image.close();
            return imageBuffer;
        }
    }
```
可以看到，缩略图的byte数组形式，是通过**ThumbnailHelper**来生成的（该类与缩略图密切相关）。  

## 1.6 ImageReader.postEventFromNative()
用于在Nativ代码中处理事件的方法，用于**触发图像可用事件的回调**。
⬜？todo：此处是从何回调而来的
`frameworks/base/media/java/android/media/ImageReader.java`  
```java
    /**
     * Called from Native code when an Event happens.
     *
     * This may be called from an arbitrary Binder thread, so access to the ImageReader must be
     * synchronized appropriately.
     */
    private static void postEventFromNative(Object selfRef) {
        @SuppressWarnings("unchecked")
        WeakReference<ImageReader> weakSelf = (WeakReference<ImageReader>)selfRef;
        final ImageReader ir = weakSelf.get();
        if (ir == null) {
            return;
        }
        final Executor executor;
        final OnImageAvailableListener listener;
        synchronized (ir.mListenerLock) {
            executor = ir.mListenerExecutor;
            listener = ir.mListener;  // private OnImageAvailableListener mListener;
        }
        final boolean isReaderValid;
        synchronized (ir.mCloseLock) {
            isReaderValid = ir.mIsReaderValid;
        }
  
        // It's dangerous to fire onImageAvailable() callback when the ImageReader
        // is being closed, as application could acquire next image in the
        // onImageAvailable() callback.
        if (executor != null && listener != null && isReaderValid) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    listener.onImageAvailable(ir);  // 触发图像可用事件的回调
                }
			});
        }
    }
```

本地方法在相机硬件捕获图像完成后，触发图像可用事件回调，到达ImageReader中进行处理，其中ImageReader中注册了一个OnImageAvailableListener的回调监听器，当图像捕获完成后，就会回调该监听器。  
本质上处理就是一直回调，到最初PhotoMode中的点击拍照。

---
在`PhotoDevice2Controller.takePicture()`中，首先通过`doCreateAndConfigRequest()`**构建了一个builder**，然后通过`mSession.capture()`来**触发相机硬件执行捕获操作**，硬件捕获完成后，会**回调**到`PhotoMode.doShutterButtonClick()`中的callback，同时**触发图像可用事件的回调**，走上面流程。

？？？上面流程和开始PhotoMode中的callback是如何交互的？（1.4中回调进了1.3PhotoMode中的callback）

## 1.7 PhotoDevice2Controller.takePicture()
触发相机硬件执行捕获操作（传入的mCaptureCallback为PhotoMode.doShutterButtonClick()传入的callback）
`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/mode/photo/device/PhotoDevice2Controller.java`
```java
    /**
     * 拍照走此处 libin
     */
    @Override
    public void takePicture(@Nonnull IDeviceController.CaptureDataCallback callback) {
        LogHelper.i(TAG, "[takePicture] mSession= " + mSession);
        CameraSysTrace.onEventSystrace("photoDevice.takePicture", true, true);
        if (mSession != null && mCamera2Proxy != null) {
            mCaptureSurface.setCaptureCallback(this);
            mCaptureDataCallback = callback;
            updateCameraState(CameraState.CAMERA_CAPTURING);  // 更新相机正处于拍照状态
            try {
                Builder builder = doCreateAndConfigRequest(Camera2Proxy.TEMPLATE_STILL_CAPTURE);  // 创建一个拍照模板请求构建器
	            // 触发相机硬件执行捕获操作（捕获请求，捕获结果回调，处理请求和结果的线程处理器）
                mSession.capture(builder.build(), mCaptureCallback, mModeHandler);
                if (mIDeviceListener != null) {
                    mIDeviceListener.onTakePicture();  // ⬜？？？如果拍照请求成功创建，则触发一个回调
                }
            } catch (CameraAccessException e) {
                e.printStackTrace();
                LogHelper.e(TAG, "[takePicture] error because create build fail.");
            }
        }
        CameraSysTrace.onEventSystrace("photoDevice.takePicture", false, true);
    }
```
相机拍照方法的实现，该方法接收一个`IDeviceController.CaptureDataCallback`作为参数，用于回调拍照的结果。通过**在这个回调中处理捕获的图像数据**，应用可执行一系列的操作，如保存图像、显示预览等等。  
### 1.7.1 Builder builder = doCreateAndConfigRequest(Camera2Proxy.TEMPLATE_STILL_CAPTURE);
**PhotoDevice2Controller.doCreateAndConfigRequest(int templateType);**  
`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/mode/photo/device/PhotoDevice2Controller.java`  
```java
private Builder doCreateAndConfigRequest(int templateType) throws CameraAccessException {
        LogHelper.i(TAG, "[doCreateAndConfigRequest] mCamera2Proxy =" + mCamera2Proxy);
        CaptureRequest.Builder builder = null;
        if (mCamera2Proxy != null) {
            builder = mCamera2Proxy.createCaptureRequest(templateType);
            if (builder == null) {
                LogHelper.d(TAG, "Builder is null, ignore this configuration");
                return null;
            }
            mSettingDevice2Configurator.configCaptureRequest(builder);
            ThumbnailHelper.configPostViewRequest(builder);
            configureQuickPreview(builder);
            configureBGService(builder);
            configurePlatformCamera(builder);
            if (Camera2Proxy.TEMPLATE_PREVIEW == templateType) {
                builder.addTarget(mPreviewSurface);
            } else if (Camera2Proxy.TEMPLATE_STILL_CAPTURE == templateType) {
                builder.addTarget(mCaptureSurface.getSurface());  // 获取照片原图 libin
                if ("off".equalsIgnoreCase(mZsdStatus)) {
                    builder.addTarget(mPreviewSurface);
                }
                // 如果支持后视图覆盖，则添加缩略图作为目标
                if (ThumbnailHelper.isPostViewOverrideSupported()) {
                    builder.addTarget(mThumbnailSurface.getSurface());  // 获取照片缩略图 libin
                }
                ThumbnailHelper.setDefaultJpegThumbnailSize(builder);
                P2DoneInfo.enableP2Done(builder);
                CameraUtil.enable4CellRequest(mCameraCharacteristics, builder);
                int rotation = CameraUtil.getJpegRotationFromDeviceSpec(
                        Integer.parseInt(mCurrentCameraId), mJpegRotation, mActivity);
                HeifHelper.orientation = rotation;
                builder.set(CaptureRequest.JPEG_ORIENTATION, rotation);
                if (mICameraContext.getLocation() != null) {
                    if (!CameraUtil.is3rdPartyIntentWithoutLocationPermission(mActivity)) {
                        builder.set(CaptureRequest.JPEG_GPS_LOCATION,
                                mICameraContext.getLocation());
                    }
                }
            }
        }
        return builder;
    }
```
`builder.addTarget(mCaptureSurface.getSurface());`  
>获取照片原图的相关信息，在`getSurface()`中完成了`OnImageAvailableListener`的注册  

`builder.addTarget(mThumbnailSurface.getSurface());`  
>获取照片缩略图的相关信息，同样在`getSurface()`中完成了`OnImageAvailableListener`的注册  

**后视图覆盖**（Post-View Override）是指在拍摄照片后，**相机将捕获的图像数据用于实时预览或显示**。通常，在用户按下快门按钮拍摄照片后，相机会捕获图像数据，然后用于生成照片。在这个过程中，相机可能会提供一个特定的模式，称为后视图覆盖模式。  

后视图覆盖的主要目的是为用户提供一个即时的预览，以便他们可以在拍摄之后立即查看照片的效果。这对于用户调整相机设置、构图和确保他们捕获到满意的瞬间非常有用。    

这里检查了设备是否支持后视图覆盖，如果支持，就将照片缩略图的Surface作为目标添加到捕获请求中。这样，**当拍摄照片后，照片缩略图将会被捕获并用于实时预览显示**。

### 1.7.2 mSession.capture(builder.build(), mCaptureCallback, mModeHandler);

其中`mSession`为`Camera2CaptureSessionProxy`，`Camera2CaptureSessionProxy.capture()`用于**发送相机捕获请求**，其中包括捕获设置、捕获完成时的回调监听器等信息。  
>该方法使用了消息处理程序和原子访问器来确保捕获请求的同步执行。在捕获完成后，**返回捕获的帧数**。

`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/device/v2/Camera2CaptureSessionProxy.java`
```java
    /**
     * <p>
     * Submit a request for an image to be captured by the camera device.
     * </p>
     *
     * @param request
     *            the settings for this capture
     * @param listener
     *            The callback object to notify once this request has been processed. If null, no
     *            metadata will be produced for this capture, although image data will still be
     *            produced.
     * @param handler
     *            the handler on which the listener should be invoked, or {@code null} to use the
     *            current thread's {@link android.os.Looper looper}, if current thread have no
     *            looper will occur IllegalArgumentException.
     * @return int A unique capture sequence ID used by
     *         {@link CaptureCallback#onCaptureSequenceCompleted}.
     * @throws CameraAccessException
     *             if the camera device is no longer connected or has encountered a fatal error
     */
    public int capture(@Nonnull CaptureRequest request, @Nullable CaptureCallback listener,
                    @Nullable Handler handler) throws CameraAccessException {
        int[] captureNum = new int[1];
        List<CaptureRequest> requestList = new ArrayList<>();
        requestList.add(request);
        // 创建 Session 操作信息对象，包含捕获请求列表、回调监听器、处理程序和捕获帧数数组
        SessionOperatorInfo info = new SessionOperatorInfo(requestList, listener, handler, captureNum);
        // 通过消息处理程序发送捕获请求消息，使用相机原子访问器等待消息完成
        Message msg = mRequestHandler.obtainMessage(Camera2Actions.CAPTURE, info);
        mAtomAccessor.sendAtomMessageAndWait(mRequestHandler, msg);
        return captureNum[0];  // 返回捕获的帧数
    }
```
⬜上面的SessionOperatorInfo为用于传递捕获操作信息的类，包括捕获请求列表、捕获完成时的回调监听器、处理回调监听器事件的处理程序以及用于存储捕获的帧数的数组。通过使用这个对象，可以将所有这些信息传递给相机系统的其他部分，以便执行相应的捕获操作。
>如何传递的？回调监听器如何注册或使用的？

## 1.8 PhotoMode.doShutterButtonClick()

用于处理快门按钮点击事件。 
其中`PhotoDevice2Controller`是`IDeviceController`的实现之一，所以下一步调用的类为`PhotoDevice2Controller`。  
`mIDeviceController`是通过`deviceControllerFactory.createDeviceController()`获取的  
>而`DeviceControllerFactory.createDeviceController()`直接return的是一个`PhotoDevice2Controller`。

`vendor/mediatek/proprietary/packages/apps/Camera2/common/src/com/mediatek/camera/common/bgservice/CaptureSurface.java`
```java
    @Override
    protected boolean doShutterButtonClick() {
        //Storage case
        boolean storageReady = mICameraContext.getStorageService().getCaptureStorageSpace() > 0;
        boolean isDeviceReady = mIDeviceController.isReadyForCapture();
        LogHelper.i(TAG, "onShutterButtonClick, is storage ready : " + storageReady + "," +
                "isDeviceReady = " + isDeviceReady);
        if (storageReady && isDeviceReady && mIsResumed
                && mMemoryState != IMemoryManager.MemoryAction.STOP) {
            //trigger capture animation
            startCaptureAnimation();
            mPhotoStatusResponder.statusChanged(KEY_PHOTO_CAPTURE, PHOTO_CAPTURE_START);
            updateModeDeviceState(MODE_DEVICE_STATE_CAPTURING);
            disableAllUIExceptionShutter();
            mIDeviceController.updateGSensorOrientation(mIApp.getGSensorOrientation());
            mIDeviceController.takePicture(this);  // 触发相机设备进行拍照
        }
        return true;  // 表示已经被处理（事件已消费）
    }
```

# 2 进入拍照界面后更新缩略图

数据库中的缩略图何时存入进去的？